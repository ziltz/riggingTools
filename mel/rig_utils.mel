

/*
	
	// expression
	float $distAC = `getAttr "distanceDimensionShape1.distance"`;
	float $totalLen = `getAttr "null_CTRL.totalLength"`;
	float $midLen = `getAttr "null_CTRL.midLength"`;

	float $angle = ( pow($distAC,2)+pow($totalLen, 2)-pow($midLen,2) ) / (2*$distAC*$totalLen);

	print $angle;
	float $cosAngle;
	if (($angle > -1 ) && ($angle < 1 ))
	{
		$cosAngle = acosd($angle);
	}
	else
	{
		$cosAngle = 0;
	}

	
aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "object" -worldUpObject hipUp_LOC;


*/


/*

	rig_orientBetweenTwoPoints( $obj1,  $obj2);

*/

global proc rig_orientBetweenTwoPoints(string $obj1, string $obj2)
{

	select -cl;
	string $jnt1 = `joint -n "joint1Orient"`;
	string $jnt2 = `joint -n "joint2Orient"`;
	select -cl;
	string $jntReturn = `joint -n "oriented_JNT"`;

	delete`pointConstraint $obj1 $jnt1`;
	delete`pointConstraint $obj2 $jnt2`;

	joint -e  -oj yzx -secondaryAxisOrient zdown -zso $jnt1;

	delete`orientConstraint $jnt1 $jntReturn`;
	delete`pointConstraint $jnt1 $jnt2 $jntReturn`;

	delete $jnt1 $obj1 $obj2;

	makeIdentity -a 1 -r 1 "oriented_JNT";

}


global proc string rig_objOffset(string $obj)
{
	string $grp = `group -em -n ($obj+"Offset")`;
	delete`parentConstraint $obj $grp`;
	parent $obj $grp;

	return $grp;
}

/*
pass in object that has constraint node

*/
global proc string[] rig_returnConstrainers(string $obj)
{
	string $con[] = `listRelatives -typ "constraint" $obj`;

	string $return[] = {};
	if (size($con) > 0)
	{
		string $constrainers[] = `listAttr -ud ($con[0])`;
		
		for ($c in $constrainers)
		{
			string $target = substring ($c,1,(size($c) - 2));
			$return[size($return)] = $target;
		}
	}
	else{

		warning ("No constrainers found."+"\n");

	}

	
	return $return;
}


global proc string[] rig_constraintReturnTargets(string $con)
{

	string $targetAttrString = ( $con+ ".target" );
	string $connections[] = `listConnections $targetAttrString`;
	string $connectionsFlattened[] = stringArrayRemoveDuplicates($connections);
	string $targets[] = {};
	for ( $f in $connectionsFlattened )
	{
		if ( $f != $con )
		{
			$targets[size($targets)] = $f;
			print ( $f+ " is a target\n" );
		}
	}

	return $targets;
}


global proc string rig_stringFirst(string $list[])
{
	return $list[0];;
}


global proc string[] rig_stringToken(string $string, string $key)
{
	string $buffer[] = {};
	$numTokens = `tokenize $string $key $buffer`;

	for ($b in $buffer)
	    print ($b+"\n");

	return $buffer;
}

global proc string rig_nameGetSide(string $name)
{
	string $return = "";
	string $first = rig_stringFirst(rig_stringToken($name, "_"));
	if ( ($first == "l") || ($first == "r") )
		$return = $first;
	return $return;

}


global proc string[] rig_geoUnderGroupHierarchy(string $group)
{
	string $geos[] = `listRelatives -ad -ni -type "mesh" $group`;
	string $parents[] = {};
	for ($g in $geos)
	{
		$parents[size($parents)] = rig_stringFirst(`listRelatives -p $g`);
		
	}
	select $parents;
	return $parents;
}


global proc rig_constrainBlockGeometry()
{

	string $lowGeos[] = rig_geoUnderGroupHierarchy("lowLOD_GRP");

	for ($geo in $lowGeos)
	{
		print ("geo = "+$geo+"\n");
		string $con = rig_stringFirst(`listRelatives -typ "constraint" $geo`);
		string $sc = `findRelatedSkinCluster $geo`;
		if ( (!`objExists $con`) && (!`objExists $sc`) )
		{
			string $jntName = `substitute "JNTBLOCK" $geo "JNT"`;

			if (`gmatch $geo "*JNTBLOCK"`)
			{
				if (`objExists $jntName`)
				{
					print ("jnt = "+$jntName+"\n");
					parentConstraint -mo $jntName $geo;
				}
				else
					print ($jntName +" does not exist"+"\n");
			}
			else{
				print ($geo+" not constrained= "+"\n");
			}
		}
	}

}
